# Operation steps

Operations may be defined using a sequence of steps, rather than a
main or exec spec.

We'll use the sample project 'steps' to illustrate the behavior.

    >>> project = Project(sample("projects", "steps"))

Here's the project Guild file:

    >>> gf = guildfile.from_dir(project.cwd)

Here are the suported models:

    >>> pprint(gf.models)
    {'m1': <guild.guildfile.ModelDef 'm1'>,
     'm2': <guild.guildfile.ModelDef 'm2'>,
     'm3': <guild.guildfile.ModelDef 'm3'>,
     'm4': <guild.guildfile.ModelDef 'm4'>}

## Basic steps

Steps are stored as the operation `steps` attribute. They are no
processed by the Guild file as they are merely passed through to
`guild.steps_main` by way of the `steps` run attribute.

Here are the steps for `m1:steps-basic`.

    >>> gf.models["m1"].get_operation("steps-basic").steps
    ['step-1', 'step-2']

Note that the raw data structure is provided rather than any higher
level structured data.

The `steps-basic` operation runs the two operations in the order
specified.

    >>> project.run("m1:steps-basic")
    INFO: [guild] running step-1: m1:step-1
    hello step-1
    INFO: [guild] running step-2: m1:step-2
    hello step-2

In this case, three runs are generated:

    >>> runs = project.list_runs()
    >>> project.print_runs(runs)
    m1:step-2
    m1:step-1
    m1:steps-basic

Here we see that by running `steps-basic`, we generated runs for
`step-1` and `step-2`.

Each run generated by a step is a normal Guild run.

Here are the files generated for `step-1` and `step-2`:

    >>> project.ls(runs[0])
    ['step-2']

    >>> project.ls(runs[1])
    ['step-1']

The stepped run `steps-basic` contains symbolic links to the two
genated runs:

    >>> project.ls(runs[2])
    ['step-1', 'step-2']

    >>> step1_target = basename(realpath(join_path(runs[2].path, "step-1")))
    >>> step1_target == runs[1].id, (step1_target, runs[1].id)
    (True, ...)

    >>> step2_target = basename(realpath(join_path(runs[2].path, "step-2")))
    >>> step2_target == runs[0].id, (step1_target, runs[0].id)
    (True, ...)

## Named steps

Steps can be named, which specifies the name of the link to
create. Names are also used when referring to the step.

The `steps-named` operation illustrates how names are used.

    >>> project.run("m1:steps-named")
    INFO: [guild] running s1: m1:step-1
    hello step-1
    INFO: [guild] running s2: m1:step-2
    hello step-2

Here are the last three runs generated:

    >>> runs = project.list_runs()[:3]
    >>> project.print_runs(runs)
    m1:step-2
    m1:step-1
    m1:steps-named

The links generated in the stepped run reflect the step names:

The stepped run `steps-basic` contains symbolic links to the two
genated runs:

    >>> project.ls(runs[2])
    ['s1', 's2']

    >>> s1_target = basename(realpath(join_path(runs[2].path, "s1")))
    >>> s1_target == runs[1].id, (s1_target, runs[1].id)
    (True, ...)

    >>> s2_target = basename(realpath(join_path(runs[2].path, "s2")))
    >>> s2_target == runs[0].id, (s1_target, runs[0].id)
    (True, ...)

## Repeated steps

If a step is run more than once, the link names for subsequent runs
use an incrementing suffix to avoid name collisions.

    >>> project.run("m1:steps-repeat")
    INFO: [guild] running step-1: m1:step-1
    hello step-1
    INFO: [guild] running step-1: m1:step-1
    hello step-1
    INFO: [guild] running step-1: m1:step-1
    hello step-1

    >>> runs = project.list_runs()[:4]
    >>> project.print_runs(runs)
    m1:step-1
    m1:step-1
    m1:step-1
    m1:steps-repeat

    >>> project.ls(runs[3])
    ['step-1', 'step-1_2', 'step-1_3']

## Stepped operations and flags

Stepped operations may contain flags like any other operation. In the
case of a stepped operation, however, flags are used as arguments to
the operations they run.

We'll illustrate using `hello`, which is an operation that prints a
message specified with the `msg` flag, which defaults to 'hello
world':

    >>> project.run("m1:hello")
    hello world

And with an explicit message:

    >>> project.run("m1:hello", flags={"msg": "hello from test"})
    hello from test

The `steps-hello` operation is a stepped operation that runs `hello`
twice. It defines its own flag `msg`, which defaults to 'hello steps',
and passes that flag value through to its steps.

Here's the default behavior of `steps-hello`:

    >>> project.run("m1:steps-hello")
    INFO: [guild] running hello: m1:hello 'msg=hello steps'
    hello steps
    INFO: [guild] running hello: m1:hello 'msg=hello steps (again)'
    hello steps (again)

And with an explicit message:

    >>> project.run("m1:steps-hello", flags={"msg": "hello from test"})
    INFO: [guild] running hello: m1:hello 'msg=hello from test'
    hello from test
    INFO: [guild] running hello: m1:hello 'msg=hello from test (again)'
    hello from test (again)

If a flag value is None/null, the flag is not passed through, in which
case the default value of the step operation is used:

    >>> project.run("m1:steps-hello", flags={"msg": None})
    INFO: [guild] running hello: m1:hello
    hello world
    INFO: [guild] running hello: m1:hello 'msg=null (again)'
    null (again)

## Running operations across models

A stepped operation may run operations defined in other models. Model
`m2` illustrates this with the `composite` operation.

    >>> project.run("m2:composite")
    INFO: [guild] running hello: m2:hello 'msg=hello m2, from composite'
    hello m2, from composite
    INFO: [guild] running m1:hello: m1:hello 'msg=hello m1, from composite'
    hello m1, from composite

And with a `name` flag:

    >>> project.run("m2:composite", flags={"name": "test"})
    INFO: [guild] running hello: m2:hello 'msg=hello m2, from test'
    hello m2, from test
    INFO: [guild] running m1:hello: m1:hello 'msg=hello m1, from test'
    hello m1, from test

## Invalid steps

Step config is validated while running the stepped operation, so
invalid step configuration will cause the stepper operation to fail
with an error.

The `m3` model contains various operations that have invalid step
configuration.

    >>> project.run("m3:steps-invalid-no-steps")
    guild: operation m3:steps-invalid-no-steps is not valid:
    requires one of: main, exec, steps
    <exit 1>

    >>> project.run("m3:steps-invalid-bad-type")
    guild: invalid steps data 123: expected list
    <exit 1>

    >>> project.run("m3:steps-invalid-bad-opspec-1")
    guild: invalid step data: [1, 2, 3]
    <exit 1>

    >>> project.run("m3:steps-invalid-bad-opspec-2")
    guild: invalid step data: None
    <exit 1>

    >>> project.run("m3:steps-invalid-bad-opspec-3")
    guild: invalid step {'run': '   '}: must define run
    <exit 1>

    >>> project.run("m3:steps-invalid-bad-opspec-4")
    guild: invalid step {}: must define run
    <exit 1>

    >>> project.run("m3:steps-invalid-bad-op")
    INFO: [guild] running not-defined: m3:not-defined
    guild: cannot find operation m3:not-defined
    Try 'guild operations' for a list of available operations.
    <exit 1>


At the moment, steps do not support additional run options and any
provided will cause Guild to print a warning message.

    >>> project.run("m3:ignored-params")
    WARNING: [guild] run parameter remote used in 'm1:hello --run-dir /tmp --remote foo' ignored
    WARNING: [guild] run parameter run_dir used in 'm1:hello --run-dir /tmp --remote foo' ignored
    INFO: [guild] running m1:hello: m1:hello
    hello world

## Steps and scalars

The scalar values generated by step operations are available under the
top-level operation via the run index.

We'll use the operations in the `m4` model to illustate.

First let's delete our current runs.

    >>> project.delete_runs()
    Deleted 35 run(s)

Let's run `m4:end-to-end`, which runs the sequence of `prepare`,
`train`, and `evaluate`. This simulates a common end-to-end training
and evaluation scenario.

    >>> project.run("m4:end-to-end")
    INFO: [guild] running prepare: m4:prepare --needed
    prepared data
    INFO: [guild] running train: m4:train loss=1.0
    Resolving operation:prepare dependency
    Using output from run ... for operation:prepare resource
    loss=1.0
    INFO: [guild] running eval: m4:evaluate acc=0.5
    Resolving operation:prepare dependency
    Using output from run ... for operation:prepare resource
    Resolving operation:train dependency
    Using output from run ... for operation:train resource
    acc=0.5

Here are the generated runs:

    >>> project.print_runs(flags=True, status=True)
    m4:evaluate    acc=0.5           completed
    m4:train       loss=1.0          completed
    m4:prepare                       completed
    m4:end-to-end  acc=0.5 loss=1.0  completed

Let's look at each run in turn.

    >>> end_to_end_run = project.list_runs()[3]
    >>> end_to_end_run.opref.to_opspec()
    'm4:end-to-end'
    >>> project.ls(end_to_end_run)
    ['eval', 'prepare', 'train']

    >>> prepare_run = project.list_runs()[2]
    >>> prepare_run.opref.to_opspec()
    'm4:prepare'
    >>> project.ls(prepare_run)
    ['data']

    >>> train_run = project.list_runs()[1]
    >>> train_run.opref.to_opspec()
    'm4:train'
    >>> project.ls(train_run)
    ['data', 'model']

    >>> evaluate_run = project.list_runs()[0]
    >>> evaluate_run.opref.to_opspec()
    'm4:evaluate'
    >>> project.ls(evaluate_run)
    ['data', 'model']

When we compare the runs:

    >>> project.compare()
    [['run', 'operation',     'started', 'time', 'status',   'label', 'acc', 'loss'],
     ['...', 'm4:evaluate',   '...',     '...',  'completed', None,   0.5,   None],
     ['...', 'm4:train',      '...',     '...',  'completed', None,   None,  1.0],
     ['...', 'm4:prepare',    '...',     '...',  'completed', None,   None,  None],
     ['...', 'm4:end-to-end', '...',     '...',  'completed', None,   0.5,   1.0]]

Note that `end-to-end` reflects the `loss` and `acc` of its steps.
