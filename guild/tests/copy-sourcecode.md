# Copying source code

Guild provides a flexible rule based scheme for selecting project
files as "source code" for a run. Source code is a specialized
dependency that Guild installs for a run.

Prior to 0.9, Guild copied source code to a hidden directory dedicated
to source code (`.guild/sourcecode`). The motivator was to physically
separate source code files from other project dependencies and
generated files. It allowed a run directory to be empty as a "blank
canvas" for run. Files that appeared in the run directory were either
explicitly installed as dependencies or generated by the operation.

This scheme works relatively well for Python software because Python
is designed to load uncompiled scripts from a user-configurable
path. It's straight forward to run a Python program having relocated
the source code to another location, provided the new location is
specified on the Python path.

This scheme does not work well for languages that require (or strongly
prefer) source code to remain in a consistent location across runs. In
such cases, users must configure Guild to install source code to the
run directory root.

Additionally, separating source code from other project files has been
a source of surprise and confusion for Guild users. User code that
assumes that source code is located alongside other files in a stable
directory structure (i.e. a stable project structure) may find their
scripts breaking when run with Guild.

As of 0.9, Guild addresses these problems by copying source code to
the run directory root by default. Guild takes a new philosophy that a
run directory should resemble the project directory, maintaining the
directory structure that a user is accustomed to seeing.

This change of pilosophy makes new language support easier and
generates less surprise and confusion to users.

Guild continues to use the same source code copy rules and engine that
were in effect prior to 0.9. This scheme provides a default set of
rules that a user can append to in Guild file configuration.

Default rules are determined by whether or not a project is under
version control. If a project is under version control, Guild consults
the version control system for a list files to ignore when considering
files as source code. Guild further provides support for extending the
ignore rules with its own `guildignore` scheme.

Guild 0.9 only supports Git for project version control.

If a project is not under source control, Guild applies the default
source code copy rules in effect for versions prior to 0.9.

The tests below illustrate the various scenarios for source code copy.

Isolate our runs using a unique Guild home:

    >>> set_guild_home(mkdtemp())

## Default rules for non-VCS project

The default rules for a project that isn't configured with version
control (i.e. is not in a Git repo) are defined by Guild core and by
plugins enabled for the applicable operation.

To illustrate, we need a project that isn't associated with a Git
repo.

    >>> non_repo_project = mkdtemp()
    >>> copytree(sample("projects", "copy-sourcecode"), non_repo_project)

Ensure that the copied project doesn't contain any additional
generated pyc files under `__pycache__`.

    >>> import glob
    >>> for path in glob.glob(path(non_repo_project, "__pycache__", "*.*.pyc")):
    ...     os.remove(path)

Verify the copied project files.

    >>> find(non_repo_project)  # doctest: +REPORT_UDIFF
    .guildignore
    .hidden/file-1
    .hidden/file-2
    __pycache__/hello.pyc
    config.in.yml
    config.yml
    data/file1
    data/file2
    data/file3
    empty
    guild.yml
    hello.R
    hello.erl
    hello.py
    hello.pyc
    hello.sh
    nocopy_dir/.guild-nocopy
    nocopy_dir/not-to-copy
    subdir/logo.png
    venv/bin/activate

    >>> cd(non_repo_project)

To test initial default behavior, we remove `.guildignore` because it
specifies files to ignore when a project is managed under VCS (see
tests below). We'll reinstate this file later as a part of these tests.

    >>> guildignore_save = open(".guildignore").read()
    >>> rm(".guildignore")

Default source code copy for Python script:

    >>> run("guild run hello.py --test-sourcecode")  # doctest: +REPORT_UDIFF
    Copying from the current directory
    Rules:
      exclude dir .*
      exclude dir * containing .guild-nocopy
      include text * size < 1048577, max match 100
      exclude dir __pycache__
      exclude dir * containing bin/activate
      exclude dir * containing Scripts/activate
      exclude dir build
      exclude dir dist
      exclude dir *.egg-info
    Selected for copy:
      config.in.yml
      config.yml
      empty
      guild.yml
      hello.R
      hello.erl
      hello.py
      hello.sh
      data/file1
      data/file2
      data/file3
    Skipped:
      .hidden/
      __pycache__/
      nocopy_dir/
      venv/
      hello.pyc
      subdir/logo.png

Default sourcecode copy for shell script:

    >>> run("guild run hello.sh --test-sourcecode")  # doctest: +REPORT_UDIFF
    Copying from the current directory
    Rules:
      exclude dir .*
      exclude dir * containing .guild-nocopy
      include text * size < 1048577, max match 100
    Selected for copy:
      config.in.yml
      config.yml
      empty
      guild.yml
      hello.R
      hello.erl
      hello.py
      hello.sh
      data/file1
      data/file2
      data/file3
      venv/bin/activate
    Skipped:
      .hidden/
      nocopy_dir/
      hello.pyc
      __pycache__/hello.pyc
      subdir/logo.png

Source code copy for `default` operation:

    >>> run("guild run default --test-sourcecode")  # doctest: +REPORT_UDIFF
    Copying from the current directory
    Rules:
      exclude dir .*
      exclude dir * containing .guild-nocopy
      include text * size < 1048577, max match 100
      exclude dir __pycache__
      exclude dir * containing bin/activate
      exclude dir * containing Scripts/activate
      exclude dir build
      exclude dir dist
      exclude dir *.egg-info
    Selected for copy:
      config.in.yml
      config.yml
      empty
      guild.yml
      hello.R
      hello.erl
      hello.py
      hello.sh
      data/file1
      data/file2
      data/file3
    Skipped:
      .hidden/
      __pycache__/
      nocopy_dir/
      venv/
      hello.pyc
      subdir/logo.png

### Operation overrides to default rules

An operation can extend the default rules using the `sourcecode`
operation attribute.

The `no-sourcecode` operation disables source code copy altogether.

    >>> run("guild run no-sourcecode --test-sourcecode")
    Copying from the current directory
    Rules:
      exclude *
    Source code copy disabled

`eplicit-sourceocode` disables all previously defined rules and adds a
single rule to copy `hello.py`.

    >>> run("guild run explicit-sourcecode --test-sourcecode")  # doctest: +REPORT_UDIFF
    Copying from the current directory
    Rules:
      exclude dir .*
      exclude dir * containing .guild-nocopy
      include text * size < 1048577, max match 100
      exclude dir __pycache__
      exclude dir * containing bin/activate
      exclude dir * containing Scripts/activate
      exclude dir build
      exclude dir dist
      exclude dir *.egg-info
      exclude *
      include hello.py
    Selected for copy:
      hello.py
    Skipped:
      .hidden/
      __pycache__/
      nocopy_dir/
      venv/
      config.in.yml
      config.yml
      empty
      guild.yml
      hello.R
      hello.erl
      hello.pyc
      hello.sh
      data/file1
      data/file2
      data/file3
      subdir/logo.png

    >>> run("guild run explicit-sourcecode -y")
    hi

    >>> run("guild ls -n")
    hello.py

`explicit-sourcecode-2` uses Guild select rules to exclude some files
from the default list.

    >>> run("guild run explicit-sourcecode-2 --test-sourcecode")  # doctest: +REPORT_UDIFF
    Copying from the current directory
    Rules:
      exclude dir .*
      exclude dir * containing .guild-nocopy
      include text * size < 1048577, max match 100
      exclude dir __pycache__
      exclude dir * containing bin/activate
      exclude dir * containing Scripts/activate
      exclude dir build
      exclude dir dist
      exclude dir *.egg-info
      exclude *.py
      exclude *.yml
    Selected for copy:
      empty
      hello.R
      hello.erl
      hello.sh
      data/file1
      data/file2
      data/file3
    Skipped:
      .hidden/
      __pycache__/
      nocopy_dir/
      venv/
      config.in.yml
      config.yml
      guild.yml
      hello.py
      hello.pyc
      subdir/logo.png

For tests that use pre-0.9 source code copy rules, see
[copy-sourcecode-legacy.md](copy-sourcecode-legacy.md).

## VCS (Git) projects

If a project is configured with VCS support, Guild uses the VCS
configuration to determine what source code files to copy.

Guild currently only supports Git VCS. Other VCS tools are not
recognized and Guild will default to the rules described above.

To illustrate, we configure the project as a Git repo.

    >>> quiet("git init .")

Currently there are no files in the Git index.

    >>> run("git ls-files")
    <exit 0>

Files that would be added to the Git index by default are considered
source code files.

    >>> run("git add -n .")  # doctest: +REPORT_UDIFF
    add '.hidden/file-1'
    add '.hidden/file-2'
    add '__pycache__/hello.pyc'
    add 'config.in.yml'
    add 'config.yml'
    add 'data/file1'
    add 'data/file2'
    add 'data/file3'
    add 'empty'
    add 'guild.yml'
    add 'hello.R'
    add 'hello.erl'
    add 'hello.py'
    add 'hello.pyc'
    add 'hello.sh'
    add 'nocopy_dir/.guild-nocopy'
    add 'nocopy_dir/not-to-copy'
    add 'subdir/logo.png'
    add 'venv/bin/activate'

Guild selects the same list as the default source code for an
operation with the exception of `.guild*` files and directories
containing the sentinel `.guild-nocopy`.

    >>> run("guild run hello.py --test-sourcecode")  # doctest: +REPORT_UDIFF
    Copying from the current directory
    Rules:
      exclude dir .guild
      exclude dir * containing .guild-nocopy
      exclude dir .git
      gitignore + guildignore patterns
      exclude .git*, .guildignore
    Selected for copy:
      config.in.yml
      config.yml
      empty
      guild.yml
      hello.R
      hello.erl
      hello.py
      hello.pyc
      hello.sh
      .hidden/file-1
      .hidden/file-2
      __pycache__/hello.pyc
      data/file1
      data/file2
      data/file3
      subdir/logo.png
      venv/bin/activate
    Skipped:
      .git/
      nocopy_dir/

We see the same behavior for the `default` operation, which does not
define additional rules.

    >>> run("guild run default --test-sourcecode")  # doctest: +REPORT_UDIFF
    Copying from the current directory
    Rules:
      exclude dir .guild
      exclude dir * containing .guild-nocopy
      exclude dir .git
      gitignore + guildignore patterns
      exclude .git*, .guildignore
    Selected for copy:
      config.in.yml
      config.yml
      empty
      guild.yml
      hello.R
      hello.erl
      hello.py
      hello.pyc
      hello.sh
      .hidden/file-1
      .hidden/file-2
      __pycache__/hello.pyc
      data/file1
      data/file2
      data/file3
      subdir/logo.png
      venv/bin/activate
    Skipped:
      .git/
      nocopy_dir/

### gitignore

Guild applies the [gitignore](https://git-scm.com/docs/gitignore)
rules when selecting source code files to copy.

The Git repository for the newly created project does not have any
`.gitignore` files.

    >>> ".gitignore" in findl(".")
    False

Let's create `.gitignore` to specify some ignore patterns.

    >>> write(".gitignore", """*.in.*
    ... data
    ... *.pyc
    ... """)

With this addition, Guild ignores files and directories matching these
patterns.

Under more current versions of Git, Guild knows to implicitly ignore
the directory `__pycache__`. As an optimization, `__pycache__` is
explicitly excluded as a directory. This precents Guild from
traversing the directory to apply select rules.

    >>> run("guild run hello.py --test-sourcecode")
    ... # doctest: +REPORT_UDIFF +GIT_LS_FILES_TARGET
    Copying from the current directory
    Rules:
      exclude dir .guild
      exclude dir * containing .guild-nocopy
      exclude dir .git, __pycache__, data
      gitignore + guildignore patterns
      exclude .git*, .guildignore
    Selected for copy:
      config.yml
      empty
      guild.yml
      hello.R
      hello.erl
      hello.py
      hello.sh
      .hidden/file-1
      .hidden/file-2
      subdir/logo.png
      venv/bin/activate
    Skipped:
      .git/
      __pycache__/
      data/
      nocopy_dir/
      .gitignore
      config.in.yml
      hello.pyc

Earlier versions of Git do not support implicit directory listings for
ignored files. In this case, Guild does not include `__pycache__` in
the list of excluded directories. However, Guild does correctly skip
files matching `*.pyc` based on the gitignore rule.

    >>> run("guild run hello.py --test-sourcecode")
    ... # doctest: +REPORT_UDIFF -GIT_LS_FILES_TARGET
    Copying from the current directory
    Rules:
      exclude dir .guild
      exclude dir * containing .guild-nocopy
      exclude dir .git, data
      gitignore + guildignore patterns
      exclude .git*, .guildignore
    Selected for copy:
      config.yml
      empty
      guild.yml
      hello.R
      hello.erl
      hello.py
      hello.sh
      .hidden/file-1
      .hidden/file-2
      subdir/logo.png
      venv/bin/activate
    Skipped:
      .git/
      data/
      nocopy_dir/
      .gitignore
      config.in.yml
      hello.pyc
      __pycache__/hello.pyc

### guildignore

Guild's VCS source code copy scheme also supports a `.guildignore`
file, which provides additional ignore rules following the gitignore
convention. This is useful when files that are stored in Git should be
excluded as source code for a run.

Let's create `.guildignore` to exclude non Python source files and
files under `.hidden`.

    >>> write(".guildignore", """*.R
    ... *.erl
    ... *.sh
    ... file-*
    ... """)

Guild skips the newly ignored files. In more recent versions of Git,
Guild includes the optimiation of excluding `.hidden` as a directory.

    >>> run("guild run hello.py --test-sourcecode")
    ... # doctest: +REPORT_UDIFF +GIT_LS_FILES_TARGET
    Copying from the current directory
    Rules:
      exclude dir .guild
      exclude dir * containing .guild-nocopy
      exclude dir .git, .hidden, __pycache__, data
      gitignore + guildignore patterns
      exclude .git*, .guildignore
    Selected for copy:
      config.yml
      empty
      guild.yml
      hello.py
      subdir/logo.png
      venv/bin/activate
    Skipped:
      .git/
      .hidden/
      __pycache__/
      data/
      nocopy_dir/
      .gitignore
      .guildignore
      config.in.yml
      hello.R
      hello.erl
      hello.pyc
      hello.sh

Using older versions of Git, the files in `.guildignore` are still
ignored, along with the other files selected via `gitignore`. However,
Guild does not apply the optimization of excluding `__pycache__` and
`.hidden` directories.

    >>> run("guild run hello.py --test-sourcecode")
    ... # doctest: +REPORT_UDIFF -GIT_LS_FILES_TARGET
    Copying from the current directory
    Rules:
      exclude dir .guild
      exclude dir * containing .guild-nocopy
      exclude dir .git, data
      gitignore + guildignore patterns
      exclude .git*, .guildignore
    Selected for copy:
      config.yml
      empty
      guild.yml
      hello.py
      subdir/logo.png
      venv/bin/activate
    Skipped:
      .git/
      data/
      nocopy_dir/
      .gitignore
      .guildignore
      config.in.yml
      hello.R
      hello.erl
      hello.pyc
      hello.sh
      .hidden/file-1
      .hidden/file-2
      __pycache__/hello.pyc

`.guildignore` may be used to negate a previously defined rule.

Here we append a rule to re-enable `data` as source code.

    >>> write(".guildignore", """!data
    ... """, append=True)

    >>> run("guild run hello.py --test-sourcecode")
    ... # doctest: +REPORT_UDIFF +GIT_LS_FILES_TARGET
    Copying from the current directory
    Rules:
      exclude dir .guild
      exclude dir * containing .guild-nocopy
      exclude dir .git, .hidden, __pycache__
      gitignore + guildignore patterns
      exclude .git*, .guildignore
    Selected for copy:
      config.yml
      empty
      guild.yml
      hello.py
      data/file1
      data/file2
      data/file3
      subdir/logo.png
      venv/bin/activate
    Skipped:
      .git/
      .hidden/
      __pycache__/
      nocopy_dir/
      .gitignore
      .guildignore
      config.in.yml
      hello.R
      hello.erl
      hello.pyc
      hello.sh

As with previous examples, the behavior in older versions of Git is
the same, with the exception of the missing directory optimizations.

    >>> run("guild run hello.py --test-sourcecode")
    ... # doctest: +REPORT_UDIFF -GIT_LS_FILES_TARGET
    Copying from the current directory
    Rules:
      exclude dir .guild
      exclude dir * containing .guild-nocopy
      exclude dir .git
      gitignore + guildignore patterns
      exclude .git*, .guildignore
    Selected for copy:
      config.yml
      empty
      guild.yml
      hello.py
      data/file1
      data/file2
      data/file3
      subdir/logo.png
      venv/bin/activate
    Skipped:
      .git/
      nocopy_dir/
      .gitignore
      .guildignore
      config.in.yml
      hello.R
      hello.erl
      hello.pyc
      hello.sh
      .hidden/file-1
      .hidden/file-2
      __pycache__/hello.pyc

### Operation overrides to VCS based rules

Operations can provide additional rules, which are appended to the VCS
based rules generated when a project is under VCS control.

`no-sourcecode` disables all source code for the operation.

    >>> run("guild run no-sourcecode --test-sourcecode")
    Copying from the current directory
    Rules:
      exclude *
    Source code copy disabled

    >>> run("guild run no-sourcecode -y")
    <exit 0>

    >>> run("guild ls -n")
    <exit 0>

`explicit-sourcecode` resets the rules and includes a single source
code file `hello.py`.

    >>> run("guild run explicit-sourcecode --test-sourcecode")
    ... # doctest: +REPORT_UDIFF +GIT_LS_FILES_TARGET
    Copying from the current directory
    Rules:
      exclude dir .guild
      exclude dir * containing .guild-nocopy
      exclude dir .git, .hidden, __pycache__
      gitignore + guildignore patterns
      exclude .git*, .guildignore
      exclude *
      include hello.py
    Selected for copy:
      hello.py
    Skipped:
      .git/
      .hidden/
      __pycache__/
      nocopy_dir/
      .gitignore
      .guildignore
      config.in.yml
      config.yml
      empty
      guild.yml
      hello.R
      hello.erl
      hello.pyc
      hello.sh
      data/file1
      data/file2
      data/file3
      subdir/logo.png
      venv/bin/activate

Using older versions of Git, we don't see the directory exclude
optimizations.

    >>> run("guild run explicit-sourcecode --test-sourcecode")
    ... # doctest: +REPORT_UDIFF -GIT_LS_FILES_TARGET
    Copying from the current directory
    Rules:
      exclude dir .guild
      exclude dir * containing .guild-nocopy
      exclude dir .git
      gitignore + guildignore patterns
      exclude .git*, .guildignore
      exclude *
      include hello.py
    Selected for copy:
      hello.py
    Skipped:
      .git/
      nocopy_dir/
      .gitignore
      .guildignore
      config.in.yml
      config.yml
      empty
      guild.yml
      hello.R
      hello.erl
      hello.pyc
      hello.sh
      .hidden/file-1
      .hidden/file-2
      __pycache__/hello.pyc
      data/file1
      data/file2
      data/file3
      subdir/logo.png
      venv/bin/activate

`explicit-sourcecode-2` appends two exclusion rules.

    >>> run("guild run explicit-sourcecode-2 --test-sourcecode")
    ... # doctest: +REPORT_UDIFF +GIT_LS_FILES_TARGET
    Copying from the current directory
    Rules:
      exclude dir .guild
      exclude dir * containing .guild-nocopy
      exclude dir .git, .hidden, __pycache__
      gitignore + guildignore patterns
      exclude .git*, .guildignore
      exclude *.py
      exclude *.yml
    Selected for copy:
      empty
      data/file1
      data/file2
      data/file3
      subdir/logo.png
      venv/bin/activate
    Skipped:
      .git/
      .hidden/
      __pycache__/
      nocopy_dir/
      .gitignore
      .guildignore
      config.in.yml
      config.yml
      guild.yml
      hello.R
      hello.erl
      hello.py
      hello.pyc
      hello.sh

With older versions of Git:

    >>> run("guild run explicit-sourcecode-2 --test-sourcecode")
    ... # doctest: +REPORT_UDIFF -GIT_LS_FILES_TARGET
    Copying from the current directory
    Rules:
      exclude dir .guild
      exclude dir * containing .guild-nocopy
      exclude dir .git
      gitignore + guildignore patterns
      exclude .git*, .guildignore
      exclude *.py
      exclude *.yml
    Selected for copy:
      empty
      data/file1
      data/file2
      data/file3
      subdir/logo.png
      venv/bin/activate
    Skipped:
      .git/
      nocopy_dir/
      .gitignore
      .guildignore
      config.in.yml
      config.yml
      guild.yml
      hello.R
      hello.erl
      hello.py
      hello.pyc
      hello.sh
      .hidden/file-1
      .hidden/file-2
      __pycache__/hello.pyc

## Source code and dependencies

There may be a conflict between a file considered as source code and a
file (or link) written to the run directory during dependency
resolution.

Files may conflict with source code as dependencies for a number of
reasons:

- Project local dependency (`file` type)
- Selected from an upstream run (`operation` type)
- Selected from an archive (`file` or remote URL type)

Guild indentifies project-local dependencies -- i.e. files specified
with the `file` type -- and removes them from source code file lists,
regardless of the source code rules.

As a baseline, the `default` operation, using the current project
configuration (gitignore and guildignore) copies `config.yml`.

    >>> run("guild run default --test-sourcecode")
    ... # doctest: +REPORT_UDIFF +GIT_LS_FILES_TARGET
    Copying from the current directory
    Rules:
      exclude dir .guild
      exclude dir * containing .guild-nocopy
      exclude dir .git, .hidden, __pycache__
      gitignore + guildignore patterns
      exclude .git*, .guildignore
    Selected for copy:
      config.yml
      empty
      guild.yml
      hello.py
      data/file1
      data/file2
      data/file3
      subdir/logo.png
      venv/bin/activate
    Skipped:
      .git/
      .hidden/
      __pycache__/
      nocopy_dir/
      .gitignore
      .guildignore
      config.in.yml
      hello.R
      hello.erl
      hello.pyc
      hello.sh

With older verions of Git:

    >>> run("guild run default --test-sourcecode")
    ... # doctest: +REPORT_UDIFF -GIT_LS_FILES_TARGET
    Copying from the current directory
    Rules:
      exclude dir .guild
      exclude dir * containing .guild-nocopy
      exclude dir .git
      gitignore + guildignore patterns
      exclude .git*, .guildignore
    Selected for copy:
      config.yml
      empty
      guild.yml
      hello.py
      data/file1
      data/file2
      data/file3
      subdir/logo.png
      venv/bin/activate
    Skipped:
      .git/
      nocopy_dir/
      .gitignore
      .guildignore
      config.in.yml
      hello.R
      hello.erl
      hello.pyc
      hello.sh
      .hidden/file-1
      .hidden/file-2
      __pycache__/hello.pyc

The `upstream` operation in the project requires `config.yml` and so
this file is not copied as source code.

    >>> run("guild run upstream --test-sourcecode")
    ... # doctest: +REPORT_UDIFF +GIT_LS_FILES_TARGET
    Copying from the current directory
    Rules:
      exclude dir .guild
      exclude dir * containing .guild-nocopy
      exclude dir .git, .hidden, __pycache__
      gitignore + guildignore patterns
      exclude .git*, .guildignore
    Selected for copy:
      empty
      guild.yml
      hello.py
      data/file1
      data/file2
      data/file3
      subdir/logo.png
      venv/bin/activate
    Skipped:
      .git/
      .hidden/
      __pycache__/
      nocopy_dir/
      .gitignore
      .guildignore
      config.in.yml
      config.yml
      hello.R
      hello.erl
      hello.pyc
      hello.sh

With older versions of Git:

    >>> run("guild run upstream --test-sourcecode")
    ... # doctest: +REPORT_UDIFF -GIT_LS_FILES_TARGET
    Copying from the current directory
    Rules:
      exclude dir .guild
      exclude dir * containing .guild-nocopy
      exclude dir .git
      gitignore + guildignore patterns
      exclude .git*, .guildignore
    Selected for copy:
      empty
      guild.yml
      hello.py
      data/file1
      data/file2
      data/file3
      subdir/logo.png
      venv/bin/activate
    Skipped:
      .git/
      nocopy_dir/
      .gitignore
      .guildignore
      config.in.yml
      config.yml
      hello.R
      hello.erl
      hello.pyc
      hello.sh
      .hidden/file-1
      .hidden/file-2
      __pycache__/hello.pyc

### Non-project local dependencies

Guild does not exclude non-project local dependencies from source
code. This includes files resolved from upstream runs or extracted
from archives.

The `downstream-conflict` operation defines a dependency on the
`upstream` operation. The conflict arises because Guild copies
`config.yml` as source code for `downstream-conflict`.

Guild treats `config.yml` as source code for `downstream-conflict`.

    >>> run("guild run downstream-conflict --test-sourcecode")
    ... # doctest: +REPORT_UDIFF +GIT_LS_FILES_TARGET
    WARNING: cannot find a suitable run for required resource 'operation:upstream'
    Copying from the current directory
    Rules:
      exclude dir .guild
      exclude dir * containing .guild-nocopy
      exclude dir .git, .hidden, __pycache__
      gitignore + guildignore patterns
      exclude .git*, .guildignore
    Selected for copy:
      config.yml
      empty
      guild.yml
      hello.py
      data/file1
      data/file2
      data/file3
      subdir/logo.png
      venv/bin/activate
    Skipped:
      .git/
      .hidden/
      __pycache__/
      nocopy_dir/
      .gitignore
      .guildignore
      config.in.yml
      hello.R
      hello.erl
      hello.pyc
      hello.sh

To show the problem, we create the required `upstream` run.

    >>> run("guild run upstream -y")
    Resolving file:config.yml

In this case, Guild treats `config.yml` as a dependency and not as
source code.

    >>> run("guild ls -n --dependencies")
    config.yml

Show source code.

    >>> run("guild ls -n --sourcecode")
    data/file1
    data/file2
    data/file3
    empty
    guild.yml
    hello.py
    subdir/logo.png
    venv/bin/activate

When we run `downstream-conflict` we see the conflict.

    >>> run("guild run downstream-conflict -y")
    Resolving operation:upstream
    Using run ... for operation:upstream
    WARNING: .../config.yml already exists, skipping copy

The `downstream-fixed` operation is configured to exclude `config.yml`
as source code.

    >>> run("guild run downstream-fixed --test-sourcecode")
    ... # doctest: +REPORT_UDIFF +GIT_LS_FILES_TARGET
    Copying from the current directory
    Rules:
      exclude dir .guild
      exclude dir * containing .guild-nocopy
      exclude dir .git, .hidden, __pycache__
      gitignore + guildignore patterns
      exclude .git*, .guildignore
      exclude config.yml
    Selected for copy:
      empty
      guild.yml
      hello.py
      data/file1
      data/file2
      data/file3
      subdir/logo.png
      venv/bin/activate
    Skipped:
      .git/
      .hidden/
      __pycache__/
      nocopy_dir/
      .gitignore
      .guildignore
      config.in.yml
      config.yml
      hello.R
      hello.erl
      hello.pyc
      hello.sh

When we run the operation, it runs without conflicts.

    >>> run("guild run downstream-fixed -y")
    Resolving operation:upstream
    Using run ... for operation:upstream

## Broken Git configuration

To use Git, Guild relies on the `git` executable being available on
the system path (i.e. in a directory specified in the `PATH`
environment variable). Alternative, the user can configure the Git
executable in user config under the `git.executable` attribute.

If Git is unavailable to test a project for source code copy rules,
Guild logs a warning message when run inside Git repositories. In this
case the user is attempting to run an operation inside a Git
repository, which controls the source code rules, but does not have
Git available to run.

In this case, Guild falls back on its default source code copy rules.

To illustrate, create a project directory and initialize it as a Git
repository.

    >>> cd(mkdtemp())
    >>> quiet("git init")

Create user configuration inside the project. Guild uses this
configuration when running project operations.

    >>> write("guild-config.yml", """
    ... git:
    ...   executable: not-a-git-exe
    ... """)

Create a script to run.

    >>> touch("test.py")

Create another file that is a source code candidate.

    >>> touch("test.txt")

Configure Git to ignore `*.txt` files.

    >>> write(".gitignore", "*.txt")

Test the source code copy rules for `test.py`.

    >>> run("guild run test.py --test-sourcecode")
    WARNING: The current project appears to use Git for version control
    but git is not available on the system path. To apply Git's source
    code rules to this run, install Git [1] or specify the Git executable
    in Guild user config [2].
    <BLANKLINE>
    [1] https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)
    [2] https://my.guild.ai/t/user-config-reference
    <BLANKLINE>
    To disable this warning, set 'NO_WARN_GIT_MISSING=1'
    <BLANKLINE>
    Copying from the current directory
    Rules:
      exclude dir .*
      exclude dir * containing .guild-nocopy
      include text * size < 1048577, max match 100
      exclude dir __pycache__
      exclude dir * containing bin/activate
      exclude dir * containing Scripts/activate
      exclude dir build
      exclude dir dist
      exclude dir *.egg-info
    Selected for copy:
      .gitignore
      guild-config.yml
      test.py
      test.txt
    Skipped:
      .git/

When we have Git configured correctly, Guild uses the Git rules.

Use an explicit path to the Git exe.

    >>> write("guild-config.yml", f"""
    ... git:
    ...   executable: {which('git')}
    ... """)

    >>> run("guild run test.py --test-sourcecode")
    Copying from the current directory
    Rules:
      exclude dir .guild
      exclude dir * containing .guild-nocopy
      exclude dir .git
      gitignore + guildignore patterns
      exclude .git*, .guildignore
    Selected for copy:
      guild-config.yml
      test.py
    Skipped:
      .git/
      .gitignore
      test.txt

Rely on the default from Guild.

    >>> write("guild-config.yml", "")

    >>> run("guild run test.py --test-sourcecode")
    Copying from the current directory
    Rules:
      exclude dir .guild
      exclude dir * containing .guild-nocopy
      exclude dir .git
      gitignore + guildignore patterns
      exclude .git*, .guildignore
    Selected for copy:
      guild-config.yml
      test.py
    Skipped:
      .git/
      .gitignore
      test.txt
